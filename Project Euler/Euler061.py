# Project Euler Problem 61: "Cyclical figurate numbers"
# 
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers
# and are generated by the following formulae:
# 
# Triangle        P3,n=n(n+1)/2       1, 3, 6, 10, 15, ...
# Square      P4,n=n2     1, 4, 9, 16, 25, ...
# Pentagonal      P5,n=n(3n-1)/2      1, 5, 12, 22, 35, ...
# Hexagonal       P6,n=n(2n-1)        1, 6, 15, 28, 45, ...
# Heptagonal      P7,n=n(5n-3)/2      1, 7, 18, 34, 55, ...
# Octagonal       P8,n=n(3n-2)        1, 8, 21, 40, 65, ...
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
# 
# The set is cyclic, in that the last two digits of each number is the first two digits of the next number
# (including the last number with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882),
# is represented by a different number in the set.
# This is the only set of 4-digit numbers with this property.
#
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
# triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

import sys
sys.path.insert(0, './Utils')
from Utils import CalculateTriangular, CalculatePentagonal, CalculateHexagonal, CalculateHeptagonal, CalculateOctagonal
import benchmark

def CalculateFigurate(figurate, n):
    if figurate == 0:
        result = CalculateTriangular(n)
    elif figurate == 1:
        result = n**2
    elif figurate == 2:
        result = CalculatePentagonal(n)
    elif figurate == 3:
        result = CalculateHexagonal(n)
    elif figurate == 4:
        result = CalculateHeptagonal(n)
    else:
        result = CalculateOctagonal(n)
    return result

def LookForNextCycle(figurateChain, indicesInChain, figurates):
    figurateTypesLeft = 6 - len(indicesInChain)
    
    if figurateTypesLeft > 0:
        for i in range (0, 6):
            if i not in indicesInChain:
                for figurate in figurates[i]:
                    if figurateChain[-1][-2:] == figurate[:2]:
                        figurateChain.append(figurate)
                        indicesInChain.append(i)
                        LookForNextCycle(figurateChain, indicesInChain, figurates)
                        del figurateChain[-1]
                        del indicesInChain[-1]
    else:
        if figurateChain[-1][-2:] == figurateChain[0][:2]:
            print ("Found chain: ")
            print (str(figurateChain))

            sumOfFigurates = 0
            for figurate in figurateChain:
                sumOfFigurates += int(figurate)

            print ("The sum of these figurates is " + str(sumOfFigurates))

            exit()
    return

P = [0, 0, 0, 0, 0, 0]
n = [0, 0, 0, 0, 0, 0]
figurates = [[],[],[],[],[],[]]
figuratesMax = len(P)

# Generate figurate lists.
for i in range(0, figuratesMax):
    while P[i] < 1000:
        n[i] += 1
        P[i] = CalculateFigurate(i, n[i])
    while P[i] < 10000:
        figurates[i].append(str(P[i]))
        n[i] += 1
        P[i] = CalculateFigurate(i, n[i])

# Search links for the octagonals (index 5), because there are fewer octagonals.
for a in figurates[5]:
    figurateChain = [a]
    indicesInChain = [5]
    LookForNextCycle(figurateChain, indicesInChain, figurates)
